/*! Â© Andrea Giammarchi @WebReflection */

/* jshint esversion: 6, strict: true, node: true, eqnull:true */

(function (exports, evaluate) {'use strict';

  const

    gi = imports.gi,
    GLib = gi.GLib,
    Gio = gi.Gio,
    GFile = Gio.File,

    constants = imports.jsgtk.constants,
    DIR_SEPARATOR = constants.DIR_SEPARATOR,
    TRANSFORM = constants.TRANSFORM,
    CURRENT_DIR = constants.CURRENT_DIR,
    PROGRAM_DIR = constants.PROGRAM_DIR,

    modules = Object.create(null),

    exp = {
      has: (id) => id in modules,
      get: (id) => modules[id],
      load: load
    }

  ;

  function error(module, dir) {
    throw new Error('unable to find module ' + module + ' @ ' + dir);
  }
  function getPackageJSON (module, dir) {
    let paths = [dir, CURRENT_DIR, PROGRAM_DIR];
    let content, packageJSONPath, moduleDirectory;

    // Get the global node modules path
    if (process.env.NODE_PATH) {
      let path;
      if (process.env.NODE_PATH.indexOf(':') !== -1) {
        // NODE_PATH looks like '/usr/lib/nodejs:/usr/lib/node_modules:/usr/share/javascript'
        let parts = process.env.NODE_PATH.split(':');
        path = parts.filter((part) => {
          return part.indexOf('node_modules') !== -1;
        });
      } else {
        path = [process.env.NODE_PATH]
      }
      paths.push(path[0]);
    }

    // Iterate our paths starting with local ones first in order to build the absolute path
    // to this module's directory and package.json file.
    // TODO: Global modules are not flattened like local node modules, and we may need to
    // recurse the global node_modules directory as a last resort.
    for (let i = 0, len = paths.length; i < len; i++) {
      if (paths[i].indexOf('node_modules') === -1) {
        paths[i] = paths[i] + DIR_SEPARATOR + 'node_modules';
      }
      moduleDirectory = paths[i] + DIR_SEPARATOR + module;
      packageJSONPath = moduleDirectory + DIR_SEPARATOR + 'package.json';

      let packageJSONFile = GFile.new_for_path(paths[i] + DIR_SEPARATOR + module + DIR_SEPARATOR + 'package.json');
      if (packageJSONFile.query_exists(null)) {
        try {
          content = JSON.parse(String.prototype.trim.call(packageJSONFile.load_contents(null)[1]));
          break;
        } catch (e) {}
      }
    }

    if (content) {
      return {
        content: content,
        moduleDirectory: moduleDirectory
      };
    }
    return error(module, dir);
  }

  function getModuleFile(module, dir) {
    let fd;
    // Convert relative paths
    if (module.slice(0, 3) === '..' + DIR_SEPARATOR) {
      module = '.' + DIR_SEPARATOR + module;
    }
    if (module.slice(0, 2) === '.' + DIR_SEPARATOR) {
      module = dir + DIR_SEPARATOR + module.slice(2);
    }
    if (GLib.path_is_absolute(module)) {
      if (module.slice(-3) === '.js' || module.slice(-5) === '.json') {
        fd = GFile.new_for_path(module);
      } else {
        fd = GFile.new_for_path(module + '.js');
      }
      if (fd.query_exists(null)) {
        return fd;
      } else {
        fd = GFile.new_for_path(module + DIR_SEPARATOR + 'index.js');
        if (fd.query_exists(null)) return fd;
      }
    } else {
      // Retrieve the package.json file first
      let moduleInfo = getPackageJSON(module, dir);
      let packageJSON = moduleInfo.content;
      // Store the module directory to create the entry file's absolute path
      let moduleDirectory = moduleInfo.moduleDirectory;

      let mainFile = packageJSON.main ? packageJSON.main : 'index.js';

      if (mainFile.slice(-3) !== '.js') {
        mainFile = mainFile + '.js';
      }

      let requiredModule = moduleDirectory  + DIR_SEPARATOR + mainFile;
      fd = GFile.new_for_path(requiredModule);
      if (fd.query_exists(null)) return fd;
      return error(module, dir);
    }
  }

  function load(module, dir) {
    // Check if we've already loaded this module, if so, throw an error because Babel can't handle
    // circular dependencies.
    if (global.loadedModules.indexOf(module) !== -1) {
      throw new Error('Circular dependencies detected. Try using the module\'s dist version instead.');
    }
    let fd = getModuleFile(module, dir);
    if (!fd) {
      error(module, dir);
    }
    let id = fd.get_path();
    // Add ability to require JSON files as objects
    if (id.slice(-5) === '.json') {
      let [success, json] = fd.load_contents(null);
      try {
        if (!success) {
          throw new Error();
        }
        return JSON.parse(json);
      } catch (e) {
        error(module, dir);
      }
    } else {
      global.loadedModules.push(module);
      return evaluate(TRANSFORM, modules, id, id, fd);
    }
  }

  exports.withRuntime = function setup($evaluate) {
    if (!evaluate) evaluate = $evaluate;
    return exp;
  };

}(this));
